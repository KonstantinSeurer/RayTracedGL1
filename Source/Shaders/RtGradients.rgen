// Copyright (c) 2021-2022 Sultim Tsyrendashiev
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460


// "Gradient Estimation for Real-Time Adaptive Temporal Filtering", C.Schied et al.

// Don't need albedo as gradients are calculated on demodulated direct illumination
#define MATERIAL_MAX_ALBEDO_LAYERS 0

#define DESC_SET_TLAS 0
#define DESC_SET_FRAMEBUFFERS 1
#define DESC_SET_GLOBAL_UNIFORM 2
#define DESC_SET_VERTEX_DATA 3
#define DESC_SET_TEXTURES 4
#define DESC_SET_RANDOM 5
#define DESC_SET_LIGHT_SOURCES 6
#define LIGHT_SAMPLE_METHOD (LIGHT_SAMPLE_METHOD_GRADIENTS)
#include "RaygenCommon.h"


#if GRADIENT_ESTIMATION_ENABLED


void main()
{
    const ivec2 gradPix = ivec2(gl_LaunchIDEXT.xy);
    const ivec2 screenSize = ivec2(globalUniform.renderWidth, globalUniform.renderHeight);

    if (gradPix.x * COMPUTE_ASVGF_STRATA_SIZE >= screenSize.x || gradPix.y * COMPUTE_ASVGF_STRATA_SIZE >= screenSize.y)
    {
        return;
    } 
    
    // (a) instead of choosing random sample in strata, choose the brightest
    ivec2 prevShadingPix = ivec2(0);
    ivec2 curShadingPix = ivec2(0);
    vec2 prevLuminance = vec2(0);
    for (int yy = 0; yy < COMPUTE_ASVGF_STRATA_SIZE; yy++)
    {
        for (int xx = 0; xx < COMPUTE_ASVGF_STRATA_SIZE; xx++)
        {
            // TODO: do not use same pos in strata for more than 1 frame, otherwise stale 
            /*if (prevStrataPos.x == xx && prevStrataPos.y == yy)
            {
                continue;
            }*/

            // done this way, so there are no duplicates in a strata (b)
            const ivec2 iter_curPix = gradPix * COMPUTE_ASVGF_STRATA_SIZE + ivec2(xx, yy);
            const ivec2 iter_prevPix = ivec2(floor(getPrevScreenPos(framebufMotion_Sampler, iter_curPix)));

            const vec2 iter_prevLuminance = imageLoad(framebufGradientInputs_Prev, iter_prevPix).xy;

            if (max(iter_prevLuminance.x, iter_prevLuminance.y) > max(prevLuminance.x, prevLuminance.y))
            {
                // (b) prevShadingPix is a forward-projected pixel of curShadingPix
                prevShadingPix = iter_prevPix;
                curShadingPix = iter_curPix;
                // (e) luminance of a shading sample from previous frame
                prevLuminance = iter_prevLuminance;
            }
        }
    }

    if (!testPixInRenderArea(prevShadingPix, getCheckerboardedRenderArea(curShadingPix)) || 
        isSky(texelFetchAlbedo(curShadingPix)) ||
        (prevLuminance.x <= 0.0 && prevLuminance.y <= 0.0))
    {
        imageStore(framebufDISPingGradient, gradPix, vec4(0.0));
        return;
    }

    // (f) get shading sample from current frame
    const uint oldSeed = texelFetch(framebufRandomSeed_Prev_Sampler, prevShadingPix, 0).r;

    Surface prevSurf = fetchGbufferSurface_NoAlbedoViewDir_Prev(prevShadingPix);

    // get exact position from visibility buffer, and fix up prevSurf
    // to account subpix imprecision of G-buffer's surfacePosition
    const vec4 visBufPrev = texelFetch(framebufVisibilityBuffer_Prev_Sampler, prevShadingPix, 0);
    const bool matchedSurface = unpackPrevVisibilityBuffer(visBufPrev, prevSurf.position);
    prevSurf.toViewerDir = normalize(globalUniform.cameraPositionPrev.xyz - prevSurf.position);

    vec2 forwardProjectedLuminance = vec2(0.0);

    if (matchedSurface)
    {
        Reservoir prevReservoir = imageLoadReservoir_Prev(prevShadingPix);

        if (isReservoirValid(prevReservoir))
        {
            prevReservoir.selected = lightSources_Index_PrevToCur[prevReservoir.selected];

            if (prevReservoir.selected != UINT32_MAX)
            {
                vec3 diffuse, specular;
                processDirectIllumination(oldSeed, prevSurf, prevReservoir, diffuse, specular);

                forwardProjectedLuminance = vec2(getLuminance(diffuse), getLuminance(specular));
            }
        }
    }


    vec3 gradDIS = vec3(0.0);

    {
        const float gradSample = forwardProjectedLuminance.x - prevLuminance.x;
        const float normFactor = max(forwardProjectedLuminance.x, prevLuminance.x);

        gradDIS[0] = getAntilagAlpha(gradSample, normFactor);
    }
    {
        /*
        const float gradSample = ;
        const float normFactor = ;

        gradDIS[1] = getAntilagAlpha(gradSample, normFactor);
        */
        gradDIS[1] = 0.0;
    }
    {
        const float gradSample = forwardProjectedLuminance.y - prevLuminance.y;
        const float normFactor = max(forwardProjectedLuminance.y, prevLuminance.y);

        gradDIS[2] = getAntilagAlpha(gradSample, normFactor);
    }
    

    // smooth temporally, to make antilag less aggressive over a small period of time
    {
        const ivec2 gradPixPrev = prevShadingPix / COMPUTE_ASVGF_STRATA_SIZE;

        const vec3 gradDISPrev = imageLoad(framebufDISGradientHistory, gradPixPrev).xyz;
        gradDIS = mix(gradDIS, gradDISPrev, 0.5);
    }

    imageStore(framebufDISPingGradient, gradPix, vec4(gradDIS, 0.0));
}


#else
void main() {}
#endif // GRADIENT_ESTIMATION_ENABLED